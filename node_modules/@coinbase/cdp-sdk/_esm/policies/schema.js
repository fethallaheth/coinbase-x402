import { Address } from "abitype/zod";
import { z } from "zod";
/**
 * Enum for EthValueOperator values
 */
export const EthValueOperatorEnum = z.enum([">", ">=", "<", "<=", "=="]);
/**
 * Enum for EvmAddressOperator values
 */
export const EvmAddressOperatorEnum = z.enum(["in", "not in"]);
/**
 * Enum for SolAddressOperator values
 */
export const SolAddressOperatorEnum = z.enum(["in", "not in"]);
/**
 * Schema for ETH value criterions
 */
export const EthValueCriterionSchema = z.object({
    /** The type of criterion, must be "ethValue" for Ethereum value-based rules. */
    type: z.literal("ethValue"),
    /**
     * The ETH value amount in wei to compare against, as a string.
     * Must contain only digits.
     */
    ethValue: z.string().regex(/^[0-9]+$/),
    /** The comparison operator to use for evaluating transaction values against the threshold. */
    operator: EthValueOperatorEnum,
});
/**
 * Schema for EVM address criterions
 */
export const EvmAddressCriterionSchema = z.object({
    /** The type of criterion, must be "evmAddress" for EVM address-based rules. */
    type: z.literal("evmAddress"),
    /**
     * Array of EVM addresses to compare against.
     * Each address must be a 0x-prefixed 40-character hexadecimal string.
     * Limited to a maximum of 100 addresses per criterion.
     */
    addresses: z.array(Address).max(100),
    /**
     * The operator to use for evaluating transaction addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: EvmAddressOperatorEnum,
});
/**
 * Schema for Solana address criterions
 */
export const SolAddressCriterionSchema = z.object({
    /** The type of criterion, must be "solAddress" for Solana address-based rules. */
    type: z.literal("solAddress"),
    /**
     * Array of Solana addresses to compare against.
     * Each address must be a valid Base58-encoded Solana address (32-44 characters).
     */
    addresses: z.array(z.string().regex(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)),
    /**
     * The operator to use for evaluating transaction addresses.
     * "in" checks if an address is in the provided list.
     * "not in" checks if an address is not in the provided list.
     */
    operator: SolAddressOperatorEnum,
});
/**
 * Schema for criteria used in SignEvmTransaction operations
 */
export const SignEvmTransactionCriteriaSchema = z
    .array(z.discriminatedUnion("type", [EthValueCriterionSchema, EvmAddressCriterionSchema]))
    .max(10)
    .min(1);
/**
 * Schema for criteria used in SignSolTransaction operations
 */
export const SignSolTransactionCriteriaSchema = z
    .array(z.discriminatedUnion("type", [SolAddressCriterionSchema]))
    .max(10)
    .min(1);
/**
 * Enum for Solana Operation types
 */
export const SolOperationEnum = z.enum(["signSolTransaction"]);
/**
 * Enum for Evm Operation types
 */
export const EvmOperationEnum = z.enum(["signEvmTransaction"]);
/**
 * Enum for Action types
 */
export const ActionEnum = z.enum(["reject", "accept"]);
/**
 * Type representing a 'signEvmTransaction' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
export const SignEvmTransactionRuleSchema = z.object({
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: ActionEnum,
    /**
     * The operation to which this rule applies.
     * Must be "signEvmTransaction".
     */
    operation: z.literal("signEvmTransaction"),
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: SignEvmTransactionCriteriaSchema,
});
/**
 * Type representing a 'signSolTransaction' policy rule that can accept or reject specific operations
 * based on a set of criteria.
 */
export const SignSolTransactionRuleSchema = z.object({
    /**
     * Determines whether matching the rule will cause a request to be rejected or accepted.
     * "accept" will allow the transaction, "reject" will block it.
     */
    action: ActionEnum,
    /**
     * The operation to which this rule applies.
     * Must be "signSolTransaction".
     */
    operation: z.literal("signSolTransaction"),
    /**
     * The set of criteria that must be matched for this rule to apply.
     * Must be compatible with the specified operation type.
     */
    criteria: SignSolTransactionCriteriaSchema,
});
/**
 * Schema for policy rules
 */
export const RuleSchema = z.discriminatedUnion("operation", [
    SignEvmTransactionRuleSchema,
    SignSolTransactionRuleSchema,
]);
/**
 * Enum for policy scopes
 */
export const PolicyScopeEnum = z.enum(["project", "account"]);
/**
 * Schema for creating or updating a Policy.
 */
export const CreatePolicyBodySchema = z.object({
    /**
     * The scope of the policy.
     * "project" applies to the entire project, "account" applies to specific accounts.
     */
    scope: PolicyScopeEnum,
    /**
     * An optional human-readable description for the policy.
     * Limited to 50 characters of alphanumeric characters, spaces, commas, and periods.
     */
    description: z
        .string()
        .regex(/^[A-Za-z0-9 ,.]{1,50}$/)
        .optional(),
    /**
     * Array of rules that comprise the policy.
     * Limited to a maximum of 10 rules per policy.
     */
    rules: z.array(RuleSchema).max(10).min(1),
});
export const UpdatePolicyBodySchema = z.object({
    /**
     * An optional human-readable description for the policy.
     * Limited to 50 characters of alphanumeric characters, spaces, commas, and periods.
     */
    description: z
        .string()
        .regex(/^[A-Za-z0-9 ,.]{1,50}$/)
        .optional(),
    /**
     * Array of rules that comprise the policy.
     * Limited to a maximum of 10 rules per policy.
     */
    rules: z.array(RuleSchema).max(10).min(1),
});
//# sourceMappingURL=schema.js.map